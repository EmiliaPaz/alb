{-# LANGUAGE OverloadedStrings #-}
module Solver.Parser where

import Control.Monad
import Data.Char
import Data.List
import Data.Maybe
import Text.Parsec
import Text.Parsec.Language
import Text.Parsec.String
import qualified Text.Parsec.Token as T

import Solver.PP (axiomAutoName, requirementAutoName)
import Solver.Subst
import Solver.Syntax hiding (flag)

--------------------------------------------------------------------------------

q p s = either print print (runParser (terminal p) () "" s)
q' p s = either (error . show) id (runParser (terminal p) () "" s)

followedBy p p' = try (do v <- p; p'; return v)

--------------------------------------------------------------------------------

bogusKind s = Kinded s (KVar "k")
testIdentifier p (Ident s n _) = p s

--------------------------------------------------------------------------------

tycon :: Parser Type
tycon = try (do char 'P'
                i <- integer
                guard (i >= 0) <?> "Peano literals must be naturals"
                return (foldr (:@) (TyCon (bogusKind "Z")) (replicate (fromIntegral i) (TyCon (bogusKind "S")))))
        <|> (do s <- identifier <|> operator
                let firstUpper s = let notAlpha = dropWhile (not . isAlpha) s
                                   in  null notAlpha || isUpper (head notAlpha)
                guard (testIdentifier (\s -> not (null s) && firstUpper s) s)
                          <?> "tycon must begin with an uppercase letter"
                return (TyCon (bogusKind s)))
        <|> (do i <- integer
                guard (i >= 0) <?> "Type literals must be naturals"
                return (TyLit i))

tyvar :: Parser Id
tyvar = do s <- identifier
           guard (testIdentifier (\s -> not (null s) && isLower (head (dropWhile (not . isAlpha) s))) s)
                     <?> "tyvar must begin with a lowercase letter"
           return s

typ :: Parser Type
typ = chainl1 atype (return (:@))

atype :: Parser Type
atype = parens typ <|> try tycon <|> (TyVar . bogusKind) `fmap` tyvar

flag :: Parser Flag
flag = option Inc (reserved "fails" >> return Exc)

clname :: Parser Id
clname = do s <- identifier <|> operator
            guard (testIdentifier (\s -> not (null s) && (not (isAlpha (head s)) || isUpper (head s))) s)
                      <?> "class name must begin with an uppercase letter"
            return s

predicate :: Parser Pred
predicate = do start <- getPosition
               name <- clname
               types <- many1 atype
               flag <- flag
               end <- getPosition
               return (Pred name types flag (Location start end))

qual :: Parser t -> Parser (Qual t)
qual p = do x <- p
            (:=> x) `fmap` (option [] $ try $ do reserved "if"
                                                 commaSep1 predicate)

qpred :: Parser QPred
qpred = qual predicate

axiom :: Parser Axiom
axiom = do name <- option Nothing $ try $ do name <- identifier ; reservedOp ":"; return (Just name)
           ax <- semiSep1 qpred
           guard (validate ax) <?> "axioms must all refer to the same class"
           case name of
             Nothing -> return (Ax (AutoGenerated (axiomAutoName (head ax))) (map generalize ax))
             Just name -> return (Ax (UserSupplied name) (map generalize ax))
    where validate []       = True
          validate [p]      = True
          validate (p : ps) = all ((qPredName p ==) . qPredName) ps
          generalize x      = Forall (replicate (length vs) (KVar "k")) (gen 0 vs x)
              where vs = nub (vars x)

funDep :: [Id] -> Parser FunDep
funDep vars = do determining <- many tyvar
                 reservedOp "~>"
                 determined <- many1 tyvar
                 liftM2 (:~>) (mapM translate determining) (mapM translate determined)
    where translate s = case elemIndex s vars of
                          Just i -> return i
                          Nothing -> fail ("Variable " ++ fromId s ++ " not in fundep variable list")

funDepRule :: Parser (Id, [FunDep])
funDepRule = do name <- clname
                vars <- many1 tyvar
                reservedOp "|"
                fds <- commaSep1 (funDep vars)
                return (name, fds)

requirement :: Parser (Scheme Requirement)
requirement = do ps <- commaSep1 predicate
                 reserved "requires"
                 qs <- commaSep1 (do name <- option Nothing $ try $ do name <- identifier ; reservedOp ":"; return (Just name)
                                     p <- predicate
                                     return (name, p))
                 let qs' = [(fromMaybe (requirementAutoName ps q) mname, q) | (mname, q) <- qs]
                 return (generalize (Requires ps qs'))
    where generalize x = Forall (replicate (length vs) (KVar "k")) (gen 0 vs x)
              where vs = nub (vars x)



opacity :: [Id] -> Parser Int
opacity vars = do reserved "opaque"
                  translate =<< tyvar
    where translate s = case elemIndex s vars of
                          Just i -> return i
                          Nothing -> fail ("Variable " ++ fromId s ++ " not in opacity variable list")

opacityRule :: Parser (Id, [Int])
opacityRule = do name <- clname
                 vars <- many1 tyvar
                 reservedOp "|"
                 ops <- commaSep1 (opacity vars)
                 return (name, ops)

top :: Parser Top
top = Query `fmap` (qual (commaSep predicate) `followedBy` symbol "?")
      <|> try (do ax <- axiom
                  gfp <- try (symbol "!" >> return True) <|> (symbol "." >> return False)
                  return (Axiom ax gfp))
      <|> FunDep `fmap` (funDepRule `followedBy` symbol ".")
      <|> Opacity `fmap` (opacityRule `followedBy` symbol ".")
      <|> Requirement `fmap` (requirement `followedBy` symbol ".")

--------------------------------------------------------------------------------

style = haskellStyle { T.reservedNames = ["if", "fails", "requires", "opaque"], T.reservedOpNames = [".", "|", ";", "?", "!"]
                     , T.identStart = char '$' <|> char '_' <|> T.identStart haskellStyle
                     , T.identLetter = char '$' <|> T.identLetter haskellStyle }

lexer = T.makeTokenParser style

identifier  :: Parser Id
identifier  = fromString `fmap` T.identifier lexer

reserved    :: String -> Parser ()
reserved    = T.reserved lexer

operator    :: Parser Id
operator    = fromString `fmap` T.operator lexer

reservedOp  :: String -> Parser ()
reservedOp  = T.reservedOp lexer

natural     :: Parser Integer
natural     = T.natural lexer

integer     :: Parser Integer
integer     = T.integer lexer

decimal     :: Parser Integer
decimal     = T.decimal lexer

hexadecimal :: Parser Integer
hexadecimal = T.hexadecimal lexer

octal       :: Parser Integer
octal       = T.octal lexer

symbol      :: String -> Parser String
symbol      = T.symbol lexer

lexeme      :: Parser a -> Parser a
lexeme      = T.lexeme lexer

parens      :: Parser a -> Parser a
parens      = T.parens lexer

braces      :: Parser a -> Parser a
braces      = T.braces lexer

angles      :: Parser a -> Parser a
angles      = T.angles lexer

brackets    :: Parser a -> Parser a
brackets    = T.brackets lexer

semi        :: Parser String
semi        = T.semi lexer

comma       :: Parser String
comma       = T.comma lexer

colon       :: Parser String
colon       = T.colon lexer

dot         :: Parser String
dot         = T.dot lexer

semiSep     :: Parser a -> Parser [a]
semiSep     = T.semiSep lexer

semiSep1    :: Parser a -> Parser [a]
semiSep1    = T.semiSep1 lexer

commaSep    :: Parser a -> Parser [a]
commaSep    = T.commaSep lexer

commaSep1   :: Parser a -> Parser [a]
commaSep1   = T.commaSep1 lexer

whiteSpace  :: Parser ()
whiteSpace  = T.whiteSpace lexer

terminal :: Parser t -> Parser t
terminal p = do v <- p ; eof ; return v
